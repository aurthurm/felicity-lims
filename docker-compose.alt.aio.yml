# Alternative 2: All-In-One (AIO) Deployment (with Caddy/Nginx)
# This configuration uses a single 'beak-aio' container for both webapp and API.
# It can be fronted by either Nginx or Caddy. All databases and supporting services are containerized.

networks:
  beaknet:
    driver: bridge # Defines a bridge network for inter-service communication

# Named volumes for persistent data storage for all stateful Docker services.
volumes:
  dragonfly_data: # Volume for DragonflyDB data
  dbgate_data: # Volume for DbGate configuration and data
  beak_media: # Volume for application media files (e.g., uploads)
  minio_data: # Volume for MinIO object storage data
  postgres_data: # Volume for PostgreSQL database data
  mongo_data: # Volume for MongoDB database data
  caddy_data: # Volume for Caddy's managed data (certificates, etc.)
  caddy_config: # Volume for Caddy's configuration

services:
  # Option 1: Nginx as the primary reverse proxy
  beak-aio-nginx:
    container_name: beak-aio-nginx
    image: nginx:1.25.3-alpine # Pinned image version
    restart: unless-stopped
    # Uncomment these ports if you want to use Nginx as the primary entry point
    # and comment out Caddy's ports below to avoid conflicts.
    ports:
      - '80:80' # Expose Nginx on host port 80
    environment:
      PROXY_BACKEND: beak-aio # Backend service name for AIO app
      PROXY_PORT: 8000 # Port of the AIO app
      SERVER_HOST: ${SERVER_HOST} # Hostname for Nginx (from .env)
    volumes:
      - ./services/nginx/proxy/:/etc/nginx/templates/ # Mount Nginx config for AIO
    depends_on:
      - beak-aio # Ensure AIO app is up before Nginx starts
    networks:
      - beaknet
    logging:
      options:
        max-size: 10m
        max-file: 5

  # Option 2: Caddy as the primary reverse proxy
  beak-aio-caddy:
    container_name: beak-aio-caddy
    image: caddy:2.7.6-alpine # Pinned Caddy image version
    restart: unless-stopped
    # Uncomment these ports if you want to use Caddy as the primary entry point
    # and comment out Nginx's ports above to avoid conflicts.
    ports:
      - '80:80' # Expose Caddy on host port 80 (HTTP)
      - '443:443' # Expose Caddy on host port 443 (HTTPS)
    volumes:
      # Mount your Caddyfile for AIO services (ensure this path exists)
      - ./services/caddy/aio/Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy_data:/data # Caddy's managed data (certificates, etc.)
      - caddy_config:/config # Caddy's configuration
    environment:
      PROXY_BACKEND: beak-aio # Backend service name for AIO app
      PROXY_PORT: 8000 # Port of the AIO app
      SERVER_HOST: ${SERVER_HOST} # Hostname for Caddy (from .env)
    depends_on:
      - beak-aio # Ensure AIO app is up before Caddy starts
    networks:
      - beaknet
    healthcheck: # Health check for Caddy
      test: [ 'CMD', 'curl', '-f', 'http://localhost/health' ] # Adjust if Caddy has a specific health endpoint
      interval: 10s
      timeout: 5s
      retries: 5

  beak-aio:
    container_name: beak-aio
    image: amusendame/beak-lims:aio-0.2.3 # Pinned image version
    restart: unless-stopped
    env_file:
      - .env # Load environment variables from .env file
    environment:
      POSTGRES_SERVER: beak-postgres
      SERVE_WEBAPP: True # AIO serves the webapp
      REDIS_SERVER: redis://beak-dragonfly:6379
      MONGODB_SERVER: beak-mongo:27017
      MONGODB_USER: beak # Consider using ${MONGO_INITDB_ROOT_USERNAME} from .env
      MONGODB_PASS: beak # Consider using ${MONGO_INITDB_ROOT_PASSWORD} from .env
      MINIO_SERVER: beak-minio:9000
      MINIO_ACCESS: beak # Consider using ${MINIO_ROOT_USER} from .env
      MINIO_SECRET: beak # Consider using ${MINIO_ROOT_PASSWORD} from .env
    ports:
      - 8000:8000 # Expose AIO app on host port 8000 for direct access (or proxy only)
    networks:
      - beaknet
    depends_on:
      beak-postgres:
        condition: service_healthy
      beak-dragonfly:
        condition: service_healthy
      beak-minio:
        condition: service_healthy
      beak-mongo:
        condition: service_healthy
    logging:
      options:
        max-size: 10m
        max-file: 5

  beak-minio:
    container_name: beak-minio
    image: bitnami/minio:2024.7.31 # Pinned image version
    restart: unless-stopped
    ports:
      - '9000:9000' # Expose MinIO API on host port 9000
      - '9001:9001' # Expose MinIO Console on host port 9001
    networks:
      - beaknet
    volumes:
      - minio_data:/data # Persistent volume
    environment:
      MINIO_ROOT_USER: beak # Consider using ${MINIO_ROOT_USER} from .env
      MINIO_ROOT_PASSWORD: beak # Consider using ${MINIO_ROOT_PASSWORD} from .env
      MINIO_DEFAULT_BUCKET: beak
    command: minio server /data --console-address ":9001"
    healthcheck:
      test: [ 'CMD', 'curl', '-f', 'http://localhost:9000/minio/health/live' ]
      interval: 30s
      timeout: 5s
      retries: 3

  beak-dragonfly:
    container_name: beak-dragonfly
    image: 'docker.dragonflydb.io/dragonflydb/dragonfly:latest' # Pinned image version
    restart: unless-stopped
    environment:
      - DFLY_proactor_threads=4
      - DFLY_maxmemory=1G
    ulimits:
      memlock: -1
    ports:
      - '6379:6379' # Expose DragonflyDB on host port 6379
    volumes:
      - dragonfly_data:/data # Persistent volume
    networks:
      - beaknet
    healthcheck:
      test: [ 'CMD-SHELL', 'dragonfly-cmd ping' ]
      interval: 10s
      timeout: 5s
      retries: 5

  beak-postgres:
    container_name: beak-postgres
    image: postgres:12.18 # Pinned image version
    restart: unless-stopped
    environment:
      POSTGRES_DB: beak_lims
      POSTGRES_USER: beak # Consider using ${POSTGRES_USER} from .env
      POSTGRES_PASSWORD: beak # Consider using ${POSTGRES_PASSWORD} from .env
      POSTGRES_HOST_AUTH_METHOD: trust # Acceptable for development
    volumes:
      - ./services/postgres/init/:/docker-entrypoint-initdb.d/ # Init scripts
      - postgres_data:/var/lib/postgresql/data # Persistent volume
    ports:
      - 5434:5432 # Expose PostgreSQL on host port 5434
    networks:
      - beaknet
    healthcheck:
      test: [ 'CMD-SHELL', 'pg_isready -U beak' ]
      interval: 10s
      timeout: 5s
      retries: 5

  beak-mongo:
    container_name: beak-mongo
    image: mongo:7.0.9 # Pinned image version
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: beak # Consider using ${MONGO_INITDB_ROOT_USERNAME} from .env
      MONGO_INITDB_ROOT_PASSWORD: beak # Consider using ${MONGO_INITDB_ROOT_PASSWORD} from .env
    volumes:
      - mongo_data:/data/db # Persistent volume
    ports:
      - '27027:27017' # Expose MongoDB on host port 27027
    networks:
      - beaknet
    healthcheck:
      test: [ 'CMD', 'mongosh', '--eval', "db.adminCommand('ping')" ]
      interval: 10s
      timeout: 5s
      retries: 5

  beak-dbgate:
    container_name: beak-dbgate
    image: dbgate/dbgate:1.50.0 # Pinned image version
    restart: always
    ports:
      - 8051:3000 # Expose DbGate on host port 8051
    volumes:
      - dbgate_data:/root/.dbgate # Persistent volume
    environment:
      LOGIN: beak # Consider using ${DBGATE_USER} from .env
      PASSWORD: beak # Consider using ${DBGATE_PASSWORD} from .env
      CONNECTIONS: pg,mg
      LABEL_pg: Beak Postgres
      SERVER_pg: beak-postgres
      USER_pg: beak # Consider using ${POSTGRES_USER} from .env
      PASSWORD_pg: beak # Consider using ${POSTGRES_PASSWORD} from .env
      DATABASE_pg: beak_lims
      PORT_pg: 5432
      ENGINE_pg: postgres@dbgate-plugin-postgres
      READONLY_pg: 1
      LABEL_mg: Beak Mongo
      URL_mg: mongodb://beak:beak@beak-mongo:27017/ # Consider using ${MONGO_INITDB_ROOT_USERNAME}:${MONGO_INITDB_ROOT_PASSWORD} from .env
      DATABASE_mg: beak_lims
      ENGINE_mg: mongo@dbgate-plugin-mongo
      READONLY_mg: 1
    networks:
      - beaknet
    depends_on:
      beak-postgres:
        condition: service_healthy
      beak-mongo:
        condition: service_healthy
